# =================================================================================================
# Azure Pipeline for Deploying the HealthApp Next.js Application to AKS
# =================================================================================================
# This pipeline is designed to be triggered on commits to the main branch.
trigger:
- main

# Define variables used throughout the pipeline.
# Important: Add secret variables in the Azure DevOps UI under 'Variables'.
# Required secret variables:
#   - ACR_SERVICE_CONNECTION: The name of your Azure Container Registry service connection.
#   - AKS_SERVICE_CONNECTION: The name of your Azure Kubernetes Service service connection.
#   - ACR_NAME: The name of your Azure Container Registry (e.g., 'myhealthappacr').
#   - AKS_CLUSTER_NAME: The name of your AKS cluster.
#   - AKS_RESOURCE_GROUP: The resource group of your AKS cluster.
#   - HOSTNAME: The public domain for your application (e.g., 'healthapp.yourdomain.com').
#   - DATABASE_URL: The connection string for your Azure PostgreSQL database.
#   - REDIS_URL: The connection string for your Azure Cache for Redis.
#   - NEXTAUTH_SECRET: A secret key for NextAuth.js.
#   - NEXTAUTH_URL: The public URL of your application (e.g., 'https://healthapp.yourdomain.com').

variables:
  # The name of the Docker image repository.
  imageRepository: 'healthapp'
  # The tag for the Docker image, using the pipeline's unique build ID.
  imageTag: '$(Build.BuildId)'
  # The name of the Kubernetes secret that will store the application's environment variables.
  kubernetesSecretName: 'healthapp-secrets'

stages:
# =================================================================================================
# BUILD STAGE
# This stage builds the Docker image, pushes it to ACR, and publishes the k8s manifests.
# =================================================================================================
- stage: Build
  displayName: 'Build and Push'
  jobs:
  - job: Build
    displayName: 'Build Docker Image and Publish Artifacts'
    pool:
      vmImage: 'ubuntu-latest'
    steps:
    # 1. Set up Node.js environment.
    - task: NodeTool@0
      displayName: 'Install Node.js'
      inputs:
        versionSpec: '22.x'

    # 2. Build the Docker image.
    - task: Docker@2
      displayName: 'Build Docker Image'
      inputs:
        command: 'build'
        containerRegistry: '$(ACR_SERVICE_CONNECTION)'
        repository: '$(imageRepository)'
        dockerfile: 'Dockerfile'
        tags: '$(imageTag)'

    # 3. Push the Docker image to Azure Container Registry.
    - task: Docker@2
      displayName: 'Push Docker Image to ACR'
      inputs:
        command: 'push'
        containerRegistry: '$(ACR_SERVICE_CONNECTION)'
        repository: '$(imageRepository)'
        tags: '$(imageTag)'

    # 4. Publish the Kubernetes manifest files as a pipeline artifact.
    - task: PublishPipelineArtifact@1
      displayName: 'Publish Kubernetes Manifests'
      inputs:
        targetPath: 'k8s'
        artifact: 'manifests'

# =================================================================================================
# DEPLOY STAGE
# This stage deploys the application to the Azure Kubernetes Service (AKS) cluster.
# =================================================================================================
- stage: Deploy
  displayName: 'Deploy to AKS'
  # This stage depends on the successful completion of the Build stage.
  dependsOn: Build
  jobs:
  - deployment: Deploy
    displayName: 'Deploy to AKS Cluster'
    pool:
      vmImage: 'ubuntu-latest'
    environment: 'production' # You can configure this environment in Azure DevOps.
    strategy:
      runOnce:
        deploy:
          steps:
          # 1. Download the Kubernetes manifests artifact.
          - task: DownloadPipelineArtifact@2
            displayName: 'Download Manifests'
            inputs:
              artifactName: 'manifests'
              downloadPath: '$(System.ArtifactsDirectory)/manifests'

          # 2. Replace tokens in the manifest files.
          - task: Bash@3
            displayName: 'Replace Tokens in Manifests'
            inputs:
              targetType: 'inline'
              script: |
                # Define the path to the manifests directory.
                MANIFEST_PATH="$(System.ArtifactsDirectory)/manifests/k8s"

                # Replace placeholders in the Kubernetes manifest files with pipeline variables.
                sed -i "s|__ACR_NAME__|$(ACR_NAME)|g" $MANIFEST_PATH/deployment.yml
                sed -i "s|__IMAGE_TAG__|$(imageTag)|g" $MANIFEST_PATH/deployment.yml
                sed -i "s|__ACR_NAME__|$(ACR_NAME)|g" $MANIFEST_PATH/migration-job.yml
                sed -i "s|__IMAGE_TAG__|$(imageTag)|g" $MANIFEST_PATH/migration-job.yml
                sed -i "s|__HOSTNAME__|$(HOSTNAME)|g" $MANIFEST_PATH/ingress.yml

          # 3. Create or update the Kubernetes secret with environment variables.
          - task: Kubernetes@1
            displayName: 'Create/Update Kubernetes Secret'
            inputs:
              connectionType: 'Azure Resource Manager'
              azureSubscriptionEndpoint: '$(AKS_SERVICE_CONNECTION)'
              resourceGroup: '$(AKS_RESOURCE_GROUP)'
              kubernetesCluster: '$(AKS_CLUSTER_NAME)'
              command: 'apply'
              useConfigurationFile: false
              inline: |
                apiVersion: v1
                kind: Secret
                metadata:
                  name: $(kubernetesSecretName)
                type: Opaque
                stringData:
                  # ============================================================================
                  # INSTRUCTIONS FOR PRODUCTION ENVIRONMENT VARIABLES
                  # ============================================================================
                  #
                  # The following environment variables are required for the application to
                  # run in production. You must create corresponding 'Secret variables' in
                  # your Azure DevOps pipeline settings for each of these.
                  #
                  # Navigate to: Project Settings > Pipelines > Library > Variable groups
                  # Or associate them directly with this pipeline under 'Variables'.
                  #
                  # For sensitive values, ensure you select 'Keep this value secret'.
                  #
                  # ============================================================================

                  # --- Application Core Settings ---
                  NODE_ENV: "production"
                  PORT: "3002"
                  # Public URL for the client-side, used in things like email links.
                  FRONTEND_URL: "$(FRONTEND_URL)"
                  # The root URL for the backend API.
                  NEXT_PUBLIC_API_URL: "$(FRONTEND_URL)/api"

                  # --- Database and Cache ---
                  DATABASE_URL: "$(DATABASE_URL)" # e.g., "postgresql://user:pass@host:port/db?schema=public"
                  REDIS_URL: "$(REDIS_URL)"       # e.g., "redis://:password@host:port"

                  # --- Authentication (Auth.js v5 & Legacy JWT) ---
                  # Auth.js v5 uses AUTH_SECRET. It's the primary secret for authentication.
                  # The codebase also supports NEXTAUTH_SECRET for backward compatibility.
                  # Set AUTH_SECRET to a long, random string (at least 32 characters).
                  AUTH_SECRET: "$(AUTH_SECRET)"
                  # The full public URL used for Auth.js callbacks.
                  NEXTAUTH_URL: "$(NEXTAUTH_URL)"
                  # The two secrets below are for a legacy JWT implementation that is still in use.
                  # For security, these should be different from each other and from AUTH_SECRET.
                  JWT_SECRET: "$(JWT_SECRET)"           # For signing access tokens.
                  JWT_REFRESH_SECRET: "$(JWT_REFRESH_SECRET)" # For signing refresh tokens.

                  # --- File Storage (e.g., Azure Blob Storage) ---
                  # Recommendation: Use Azure Blob Storage for deployments in Azure.
                  AZURE_STORAGE_ACCOUNT_NAME: "$(AZURE_STORAGE_ACCOUNT_NAME)"
                  AZURE_STORAGE_ACCOUNT_KEY: "$(AZURE_STORAGE_ACCOUNT_KEY)"
                  AZURE_STORAGE_CONTAINER_NAME: "$(AZURE_STORAGE_CONTAINER_NAME)"

                  # --- Email Notifications (e.g., SendGrid) ---
                  EMAIL_HOST: "$(EMAIL_HOST)"
                  EMAIL_PORT: "$(EMAIL_PORT)"
                  EMAIL_USER: "$(EMAIL_USER)"
                  EMAIL_PASS: "$(EMAIL_PASS)"

                  # --- Video Consultation (Daily.co) ---
                  DAILY_API_KEY: "$(DAILY_API_KEY)"
                  DAILY_API_URL: "$(DAILY_API_URL)"

                  # --- Lab Integrations ---
                  LAB_WEBHOOK_SECRET: "$(LAB_WEBHOOK_SECRET)"

                  # --- Payment Integration (Stripe) ---
                  STRIPE_PUBLISHABLE_KEY: "$(STRIPE_PUBLISHABLE_KEY)"
                  STRIPE_SECRET_KEY: "$(STRIPE_SECRET_KEY)"
                  STRIPE_WEBHOOK_SECRET: "$(STRIPE_WEBHOOK_SECRET)"

                  # --- IoT & Medical Device Integration ---
                  # CRITICAL: Store this in Azure Key Vault and access via CSI driver in production.
                  # This key must be a random string of 32-bytes (256-bit) for AES-256 encryption.
                  IOT_DATA_ENCRYPTION_KEY: "$(IOT_DATA_ENCRYPTION_KEY)"

                  # --- Notification Services (Twilio for SMS) ---
                  TWILIO_ACCOUNT_SID: "$(TWILIO_ACCOUNT_SID)"
                  TWILIO_AUTH_TOKEN: "$(TWILIO_AUTH_TOKEN)"
                  TWILIO_PHONE_NUMBER: "$(TWILIO_PHONE_NUMBER)"

                  # --- Healthcare Compliance & Security ---
                  # CRITICAL: Store this in Azure Key Vault and access via CSI driver in production.
                  # This key must be a random string of 32-bytes (256-bit) for AES-256 encryption.
                  PHI_ENCRYPTION_KEY: "$(PHI_ENCRYPTION_KEY)"
                  AUDIT_LOG_RETENTION_DAYS: "365"
                  ENABLE_HIPAA_AUDIT: "true"

          # 4. Deploy the database migration job.
          - task: Kubernetes@1
            displayName: 'Deploy Database Migration Job'
            inputs:
              connectionType: 'Azure Resource Manager'
              azureSubscriptionEndpoint: '$(AKS_SERVICE_CONNECTION)'
              resourceGroup: '$(AKS_RESOURCE_GROUP)'
              kubernetesCluster: '$(AKS_CLUSTER_NAME)'
              command: 'apply'
              useConfigurationFile: true
              configuration: '$(System.ArtifactsDirectory)/manifests/k8s/migration-job.yml'

          # 5. Set kubectl context to the AKS cluster
          - task: AzureCLI@2
            displayName: 'Set Kubectl Context'
            inputs:
              azureSubscription: '$(AKS_SERVICE_CONNECTION)'
              scriptType: 'bash'
              scriptLocation: 'inlineScript'
              inlineScript: |
                az aks get-credentials --resource-group $(AKS_RESOURCE_GROUP) --name $(AKS_CLUSTER_NAME) --overwrite-existing

          # 6. Wait for the migration job to complete.
          - task: Bash@3
            displayName: 'Wait for Migration Job Completion'
            inputs:
              targetType: 'inline'
              script: |
                # Wait for up to 5 minutes for the job to complete.
                if ! kubectl wait --for=condition=complete job/healthapp-migration-job --timeout=300s; then
                  echo "Migration job failed or timed out. Checking logs..."
                  # Get the pod name(s) for the job using its selector.
                  PODS=$(kubectl get pods --selector=job-name=healthapp-migration-job --output=jsonpath='{.items[*].metadata.name}')
                  if [ -z "$PODS" ]; then
                    echo "No pods found for the migration job. Cannot fetch logs."
                  else
                    for POD in $PODS; do
                      echo "Logs for pod $POD:"
                      # Fetch logs for each pod associated with the job.
                      kubectl logs "$POD"
                    done
                  fi
                  # Explicitly fail the pipeline step.
                  exit 1
                fi

                echo "Migration job completed successfully."

          # 7. Deploy the application using kubectl apply --prune.
          # This will create/update resources and delete any that are no longer in the manifests.
          - task: Bash@3
            displayName: 'Deploy Application (Apply & Prune)'
            inputs:
              targetType: 'inline'
              script: |
                # This command uses the kubectl context configured in the 'Set Kubectl Context' step (Step 5).
                # The --prune flag removes any resources that are no longer defined in the source manifests.
                # It identifies manageable resources using the label 'app.kubernetes.io/name=healthapp'.
                # We do not prune the migration job itself, as it's a one-off task.
                kubectl apply \
                  --prune \
                  -l app.kubernetes.io/name=healthapp \
                  -f $(System.ArtifactsDirectory)/manifests/k8s/
