version: '3.8'

services:
  # PostgreSQL Database - Single instance with placement constraints
  postgres:
    image: postgres:15-alpine
    environment:
      POSTGRES_DB: ${DB_NAME:-healthapp_prod}
      POSTGRES_USER: ${DB_USER:-healthapp_user}
      POSTGRES_PASSWORD: ${DB_PASSWORD}
      POSTGRES_INITDB_ARGS: "--auth-host=scram-sha-256"
      POSTGRES_HOST_AUTH_METHOD: scram-sha-256
    volumes:
      - postgres_data_prod:/var/lib/postgresql/data
      - /opt/healthapp/scripts/postgresql.conf:/etc/postgresql/postgresql.conf
    command: postgres -c config_file=/etc/postgresql/postgresql.conf
    ports:
      - "5433:5432"
    networks:
      - healthapp-backend
    deploy:
      replicas: 1
      placement:
        constraints:
          - node.role == manager
          - node.labels.database == true
      restart_policy:
        condition: on-failure
        delay: 5s
        max_attempts: 3
        window: 120s
      resources:
        limits:
          memory: 2G
          cpus: '1.0'
        reservations:
          memory: 1G
          cpus: '0.5'
      update_config:
        order: stop-first
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U ${DB_USER:-healthapp_user} -d ${DB_NAME:-healthapp_prod} && psql -U ${DB_USER:-healthapp_user} -d ${DB_NAME:-healthapp_prod} -c 'SELECT 1'"]
      interval: 15s
      timeout: 10s
      retries: 6
      start_period: 120s

  # Redis Cluster
  redis:
    image: redis:7-alpine
    command: >
      redis-server
      --requirepass ${REDIS_PASSWORD}
      --appendonly yes
      --appendfsync everysec
      --maxmemory 256mb
      --maxmemory-policy allkeys-lru
    volumes:
      - redis_data_prod:/data
    ports:
      - "6379:6379"
    networks:
      - healthapp-backend
    deploy:
      replicas: 1
      placement:
        constraints:
          - node.labels.cache == true
      restart_policy:
        condition: on-failure
        delay: 5s
        max_attempts: 3
      resources:
        limits:
          memory: 512M
          cpus: '0.5'
        reservations:
          memory: 256M
          cpus: '0.25'
    healthcheck:
      test: ["CMD", "redis-cli", "--pass", "${REDIS_PASSWORD}", "ping"]
      interval: 30s
      timeout: 10s
      retries: 3

  # Backend API - Horizontally scalable
  backend:
    image: healthapp-backend:${VERSION:-latest}
    environment:
      NODE_ENV: production
      PORT: 3001
      POSTGRES_HOST: postgres
      POSTGRES_PORT: 5432
      POSTGRES_DB: ${DB_NAME:-healthapp_prod}
      POSTGRES_USER: ${DB_USER:-healthapp_user}
      POSTGRES_PASSWORD: ${DB_PASSWORD}
      REDIS_HOST: redis
      REDIS_PORT: 6379
      REDIS_PASSWORD: ${REDIS_PASSWORD}
      JWT_SECRET: ${JWT_SECRET}
      JWT_EXPIRE: ${JWT_EXPIRE:-24h}
      FRONTEND_URL: ${FRONTEND_URL:-https://app.healthcareapp.com}
      LOG_LEVEL: ${LOG_LEVEL:-info}
      AWS_ACCESS_KEY_ID: ${AWS_ACCESS_KEY_ID}
      AWS_SECRET_ACCESS_KEY: ${AWS_SECRET_ACCESS_KEY}
      AWS_REGION: ${AWS_REGION:-us-east-1}
      AWS_S3_BUCKET: ${AWS_S3_BUCKET}
      # Performance tuning
      NODE_OPTIONS: "--max-old-space-size=512"
      # Connection retry configuration
      DB_CONNECT_RETRY_DELAY: 5000
      DB_CONNECT_MAX_RETRIES: 10
    secrets:
      - db_password
      - jwt_secret
      - aws_access_key
      - aws_secret_key
    volumes:
      - backend_logs_prod:/app/logs
    ports:
      - "3001:3001"
    networks:
      - healthapp-backend
      - healthapp-frontend
    depends_on:
      - postgres
      - redis
    deploy:
      replicas: 3
      placement:
        max_replicas_per_node: 2
        constraints:
          - node.labels.backend == true
      restart_policy:
        condition: on-failure
        delay: 10s
        max_attempts: 5
        window: 120s
      update_config:
        parallelism: 1
        delay: 30s
        failure_action: rollback
        order: start-first
        rollback_config:
          parallelism: 1
          delay: 30s
      resources:
        limits:
          memory: 1G
          cpus: '0.75'
        reservations:
          memory: 512M
          cpus: '0.5'
    healthcheck:
      test: ["CMD-SHELL", "curl -f http://localhost:3001/health || exit 1"]
      interval: 15s
      timeout: 10s
      retries: 5
      start_period: 120s

  # Frontend NextJS - Horizontally scalable
  frontend:
    image: healthapp-frontend:${VERSION:-latest}
    environment:
      NODE_ENV: production
      BACKEND_URL: http://backend:3001
      NEXT_PUBLIC_API_URL: ${NEXT_PUBLIC_API_URL:-https://api.healthcareapp.com/api}
      PORT: 3000
      NODE_OPTIONS: "--max-old-space-size=512"
    ports:
      - "3002:3000"
    networks:
      - healthapp-frontend
    depends_on:
      - backend
    deploy:
      replicas: 2
      placement:
        max_replicas_per_node: 2
        constraints:
          - node.labels.frontend == true
      restart_policy:
        condition: on-failure
        delay: 10s
        max_attempts: 5
        window: 120s
      update_config:
        parallelism: 1
        delay: 30s
        failure_action: rollback
        order: start-first
        rollback_config:
          parallelism: 1
          delay: 30s
      resources:
        limits:
          memory: 1G
          cpus: '0.75'
        reservations:
          memory: 512M
          cpus: '0.5'
    healthcheck:
      test: ["CMD-SHELL", "curl -f http://localhost:3000/ || exit 1"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 90s

  # NGINX Load Balancer - High availability
  nginx:
    image: nginx:alpine
    configs:
      - source: nginx_config
        target: /etc/nginx/nginx.conf
    secrets:
      - source: ssl_cert
        target: /etc/nginx/ssl/cert.pem
      - source: ssl_key
        target: /etc/nginx/ssl/key.pem
    volumes:
      - nginx_logs_prod:/var/log/nginx
    ports:
      - target: 80
        published: 80
        protocol: tcp
        mode: ingress
      - target: 443
        published: 443
        protocol: tcp
        mode: ingress
    networks:
      - healthapp-frontend
    depends_on:
      - frontend
      - backend
    deploy:
      replicas: 2
      placement:
        constraints:
          - node.role == manager
      restart_policy:
        condition: on-failure
        delay: 5s
        max_attempts: 3
      update_config:
        parallelism: 1
        delay: 30s
        failure_action: rollback
      resources:
        limits:
          memory: 256M
          cpus: '0.5'
        reservations:
          memory: 128M
          cpus: '0.25'
    healthcheck:
      test: ["CMD-SHELL", "curl -f http://localhost/health || exit 1"]
      interval: 30s
      timeout: 10s
      retries: 3

  # Monitoring - Prometheus
  prometheus:
    image: prom/prometheus:latest
    configs:
      - source: prometheus_config
        target: /etc/prometheus/prometheus.yml
    volumes:
      - prometheus_data_prod:/prometheus
    command:
      - '--config.file=/etc/prometheus/prometheus.yml'
      - '--storage.tsdb.path=/prometheus'
      - '--web.console.libraries=/etc/prometheus/console_libraries'
      - '--web.console.templates=/etc/prometheus/consoles'
      - '--storage.tsdb.retention.time=15d'
      - '--web.enable-lifecycle'
      - '--web.enable-admin-api'
    networks:
      - healthapp-monitoring
      - healthapp-backend
      - healthapp-frontend
    ports:
      - target: 9090
        published: 9090
        protocol: tcp
        mode: ingress
    deploy:
      replicas: 1
      placement:
        constraints:
          - node.role == manager
          - node.labels.monitoring == true
      restart_policy:
        condition: on-failure
      resources:
        limits:
          memory: 1G
          cpus: '0.5'
        reservations:
          memory: 512M
          cpus: '0.25'

  # Monitoring - Grafana
  grafana:
    image: grafana/grafana:latest
    environment:
      GF_SECURITY_ADMIN_PASSWORD: ${GRAFANA_PASSWORD}
      GF_USERS_ALLOW_SIGN_UP: false
      GF_SERVER_ROOT_URL: https://monitoring.healthcareapp.com
      GF_SECURITY_ALLOW_EMBEDDING: true
    secrets:
      - grafana_password
    volumes:
      - grafana_data_prod:/var/lib/grafana
    configs:
      - source: grafana_datasources
        target: /etc/grafana/provisioning/datasources/datasources.yml
      - source: grafana_dashboards
        target: /etc/grafana/provisioning/dashboards/dashboards.yml
    networks:
      - healthapp-monitoring
    ports:
      - target: 3000
        published: 3003
        protocol: tcp
        mode: ingress
    depends_on:
      - prometheus
    deploy:
      replicas: 1
      placement:
        constraints:
          - node.role == manager
          - node.labels.monitoring == true
      restart_policy:
        condition: on-failure
      resources:
        limits:
          memory: 512M
          cpus: '0.5'
        reservations:
          memory: 256M
          cpus: '0.25'

  # Backup Service
  backup:
    image: healthapp-backup:${VERSION:-latest}
    environment:
      POSTGRES_HOST: postgres
      POSTGRES_DB: ${DB_NAME:-healthapp_prod}
      POSTGRES_USER: ${DB_USER:-healthapp_user}
      POSTGRES_PASSWORD: ${DB_PASSWORD}
      AWS_ACCESS_KEY_ID: ${AWS_ACCESS_KEY_ID}
      AWS_SECRET_ACCESS_KEY: ${AWS_SECRET_ACCESS_KEY}
      AWS_S3_BACKUP_BUCKET: ${AWS_S3_BACKUP_BUCKET}
      BACKUP_SCHEDULE: "0 2 * * *"  # Daily at 2 AM
      BACKUP_RETENTION_DAYS: 30
    secrets:
      - db_password
      - aws_access_key
      - aws_secret_key
    volumes:
      - backup_data_prod:/backups
    networks:
      - healthapp-backend
    depends_on:
      - postgres
    deploy:
      replicas: 1
      placement:
        constraints:
          - node.role == manager
      restart_policy:
        condition: on-failure
      resources:
        limits:
          memory: 256M
          cpus: '0.25'
        reservations:
          memory: 128M
          cpus: '0.1'

networks:
  healthapp-backend:
    driver: overlay
    attachable: true
    driver_opts:
      encrypted: "true"
  healthapp-frontend:
    driver: overlay
    attachable: true
    driver_opts:
      encrypted: "true"
  healthapp-monitoring:
    driver: overlay
    attachable: true
    driver_opts:
      encrypted: "true"

volumes:
  postgres_data_prod:
    driver: local
  redis_data_prod:
    driver: local
  backend_logs_prod:
    driver: local
  nginx_logs_prod:
    driver: local
  prometheus_data_prod:
    driver: local
  grafana_data_prod:
    driver: local
  backup_data_prod:
    driver: local

configs:
  nginx_config:
    external: true
  prometheus_config:
    external: true
  grafana_datasources:
    external: true
  grafana_dashboards:
    external: true

secrets:
  db_password:
    external: true
  jwt_secret:
    external: true
  redis_password:
    external: true
  aws_access_key:
    external: true
  aws_secret_key:
    external: true
  ssl_cert:
    external: true
  ssl_key:
    external: true
  grafana_password:
    external: true